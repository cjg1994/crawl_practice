import re
x="chars@@1@onreadystatechange@D@addEventListener@replace@toLowerCase@rOm9XFMtA3QKV7nYsPGT4lifyWwkq5vcjH2IdxUoCbhERLaz81DNB6@@document@try@@@@substr@DOMContentLoaded@a@else@match@@for@1500@search@join@@@RegExp@B@@Thu@@@Path@window@@@@d@split@fromCharCode@N@@0@0xFF@@@@0xEDB88320@@24@@@innerHTML@https@08@@parseInt@setTimeout@@@cookie@toString@challenge@e@Expires@catch@attachEvent@@var@@false@while@06@@@charAt@Mar@div@@@length@new@@location@__jsl_clearance@f@g@@y@Array@@GMT@JgSe0upZ@12@@Nf5E@pathname@charCodeAt@@2@8@@@@@@captcha@u@TbQ@firstChild@20@createElement@22@143@reverse@@if@String@eval@href@function@36@@return@7@@1583996782"
# l=re.sub('@*$',"",x)
x=x.split("@")
# print(x)
y = "1d r=28(){12('1s.27=1s.1F+1s.o.7(/[\\?|&]1P-17/,\\'\\')',n);b.15='1t=2e.21|I|'+(28(){1d 1N=[28(r){2b r},28(1N){2b 1N},28(r){2b 26('25.F('+r+')')}],1j=[(2c+[[]][I]),(-~[]+[[]][I])+(-~[]+[[]][I]),(-~[]+[[]][I])+([-~[-~~~!![][[]]-~~~!![][[]]]]*(-~[-~~~!![][[]]-~~~!![][[]]])+[]),(-~[]+[[]][I])+[(+[])],(-~[]+[[]][I])+[1I],[-~-~~~!![][[]]-~[]-~{}-~-~~~!![][[]]],(-~[]+[[]][I])+(2c+[[]][I]),(-~[]+[[]][I])+[-~-~~~!![][[]]-~[]-~{}-~-~~~!![][[]]],(-~[]+[[]][I])+(1I+(-~-~~~!![][[]]^-~~~!![][[]])+[]),(-~[]+[[]][I])+((-~-~~~!![][[]]^-~~~!![][[]])+[]),[1I]+[(+[])],(-~[]+[[]][I])+[-~[-~-~~~!![][[]]-~~~!![][[]]+(-~~~!![][[]]-~~~!![][[]])*[-~~~!![][[]]-~~~!![][[]]]]],((-~-~~~!![][[]]^-~~~!![][[]])+[]),[1I]+[1I],(-~[]+[[]][I]),(1I+(-~-~~~!![][[]]^-~~~!![][[]])+[]),([-~[-~~~!![][[]]-~~~!![][[]]]]*(-~[-~~~!![][[]]-~~~!![][[]]])+[]),(-~[]+[[]][I])+(-~(-~[-~~~!![][[]]-~~~!![][[]]])+[[]][I]),[1I]+(-~[]+[[]][I]),[(+[])],[1I],(-~(-~[-~~~!![][[]]-~~~!![][[]]])+[[]][I]),[-~[-~-~~~!![][[]]-~~~!![][[]]+(-~~~!![][[]]-~~~!![][[]])*[-~~~!![][[]]-~~~!![][[]]]]]];m(1d r=I;r<1j.1p;r++){1j[r]=1N[[3,I,3,1I,3,I,3,1I,3,1I,3,I,1I,I,1I,3,1I,3,I,3,1I,I,3][r]](['1R',[((-~-~~~!![][[]]^-~~~!![][[]])+[])+(2c+[[]][I])],[((-~-~~~!![][[]]^-~~~!![][[]])+[])+(2c+[[]][I])],[[-~-~~~!![][[]]-~[]-~{}-~-~~~!![][[]]]+[-~-~~~!![][[]]-~[]-~{}-~-~~~!![][[]]],[-~[-~-~~~!![][[]]-~~~!![][[]]+(-~~~!![][[]]-~~~!![][[]])*[-~~~!![][[]]-~~~!![][[]]]]]+(-~[]+[[]][I])],((-~-~~~!![][[]]^-~~~!![][[]])+[]),'1I',(-~![]/~~[]+[]+[]).1k(2c),'t','5',[[-~-~~~!![][[]]-~[]-~{}-~-~~~!![][[]]]+[-~-~~~!![][[]]-~[]-~{}-~-~~~!![][[]]]],[(-~[]+[[]][I])+[(+[])]+((-~-~~~!![][[]]^-~~~!![][[]])+[])],(!{}+[]).1k(-~{}),'1J',[(-~[]+[[]][I])+(-~[]+[[]][I])+((-~-~~~!![][[]]^-~~~!![][[]])+[]),(-~[]+[[]][I])+[1I]+[1I]],'P','1x',[(-~[]+[[]][I])+(-~[]+[[]][I])+[-~[-~-~~~!![][[]]-~~~!![][[]]+(-~~~!![][[]]-~~~!![][[]])*[-~~~!![][[]]-~~~!![][[]]]]]],'G',([1I]/~~{}+[]+[[]][I]).1k(-~-~~~!![][[]]-~-~~~!![][[]]),'1Q','1E',(1I+(-~-~~~!![][[]]^-~~~!![][[]])+[]),(![]+[[]][I]).1k((-~{}+[-~~~!![][[]]-~~~!![][[]]]>>-~~~!![][[]]-~~~!![][[]]))+(2c+[[]][I])][1j[r]])};2b 1j.p('')})()+';19=v, 1C-1l-1T U:1h:20 1A;y=/;'};24((28(){c{2b !!z.6;}1a(18){2b 1f;}})()){b.6('h',r,1f)}j{b.1b('4',r)}"
#shift是JS中的方法  相当于python中的pop(0)
def myint(s,base):
    new=""
    for i in s:
        try:
            int(i,base)
            new+=i
        except:
            break
    return int(new,base)
def f(x, y=None): #这里的x只是一个形参，不要自动把他联想城市上面的参数x
    a = 0
    b = 0
    c = 0
    x = x.split() #JS中支持这种空分隔的语法，python中需要把这对引号给去掉
    # y = y || 99 #JS中这句话的意思是如果传入了第二个参数y,则将y赋值，没传入的话赋值99
    if y:
        y=y
    else:
        y=99
    a=x.pop(0)
    # while (a = x.pop(0)) && (b = (ord(a[0]) - 77.5)):  #python中好像不支持&&，而且这里的语法也有问题
    b = ord(a[0]) - 77.5
    while a and b: #&&在python相当于and
        # c = (abs(b) < 13 ? (b + 48.5) : parseInt(a, 36)) + y * c;
        try:
            myint(a,36)
            c=((b+48.5) if abs(b)<13 else myint(a,36))+y*c #parseInt和python中的int并不相同，下面会遇到问题 发现是int("=",36)会出错，不是一个数字，JS中也是NaN，但是JS会忽略等号以及之后的字符，只解析前面的
        except:
            c=None  #JS中是NaN,python中不知如何表示，先写None 再对下面代码进行改进
        if x:
            a=x.pop(0)
            b = ord(a[0]) - 77.5
        else:
            break
    return c
#JS中match是字符串方法，第一个参数可以是正则表达式，这里是匹配y中的每一个符合\w规则的字符，组成一个列表，然后调用sort方法排序，sort方法传入的是一个函数表达式
# z = f(y.match(/\w/g).sort(function (x, y) { #JS中的sort函数是将数组中的两个元素相比较，看返回值和0比较从而得到排序的位置
#     return f(x) - f(y)
# }).pop());
#python中改写 其实就是将数组中每个值都传入f函数，得到的值进行比较
# z=f(re.findall('\w',y,re.M).sort(key=lambda x:f(x))) #JS中的字符串sort()是将数组改变并将这个数组返回，所以有返回值，而python中没返回值，所以会造成f(None)导致None.split()错误
p=re.findall('\w',y,re.M) #JS中的match相当于正则中的findall
# for i in p:
#     if i==None:
#         print("*********")
#     print(f(i))
p.sort(key=lambda x:f(x))
z=f(p.pop())#这里又遇到了问题 list不存在split方法，JS中也一样;原来返回的JS代码字符串中并不是传入p作为f的参数，而是p.pop()
# print(z)
# print(type(z))
#JS代码改到这里在python中运行都是没错的
#接着改写这一段循环看看究竟这段代码得到了什么东西
#JS中replace方法，将匹配到的字符串替换为匿名函数返回的值，python中的字符串replace函数不支持传入函数作为参数
#下面循环的意思应该是 如果eval中的字符串作为直接代码执行不出错的话就会执行到break,从而跳出循环，而如果出错，那么循环继续，z自增
# while (z++) try {
#     eval(y.replace(/\b\w+\b/g, function (y) {
#         return x[f(y, z) - 1] || ("_" + y)
#     }));
#     break
# } catch (_) {}

def temp(y):
    # return x[f(y,z)-1] or ("_"+y) 因为考虑到JS中的NaN导致的undefined
    # print(f(y,z))
    try:
        j=x[int(f(y,z)-1)] #JS中数组索引为1.0可以，python只能是1
        return j
    except:
        return "_"+y
# print(f('r',56.0))
# print(x[27.0-1])
# print(temp('r')
#不知道下面\1的语法是否没错，错误，\1这种语法只能是在正则规则的表达式中
# n=re.sub('(\w+)',temp('\1'),y,re.M) #y中只有开头有个空格， #原来的JS中y只是一个形参，并不是这里的y字符串，耳饰正则中匹配出来的字符，这里考虑创建分组，然后\1引用这个分组
while z:
    try:
        l=re.findall('\w+',y)
        for k in l:
            y=y.replace(k,temp(k))
        break
    except:
        z=z+1
print(y)
# print(n) 这应该就是这段JS得到的东西
#接着就是eval和这个循环需要改变成python中的形式
#JS中eval是把字符串当成代码来运行 python中也是这样
# print(n)
# print(len(n))
# print(len(y))
# print(n==y)  #逗我？ 搞半天居然等于y?  问题在于n=re.sub('\b\w+\b',temp(y),y,re.M)根本没有匹配到这个正则，所以n就是y,根本没有发生替代
#JS中的正则和python中的正则规则好像不一样？？、 \b匹配规则不同吗
